{"ast":null,"code":"/* eslint-env browser */\nimport * as encoding from 'lib0/encoding';\nimport * as decoding from 'lib0/decoding';\nimport * as promise from 'lib0/promise';\nimport * as error from 'lib0/error';\nimport * as string from 'lib0/string';\n/**\n * @param {string} secret\n * @param {string} roomName\n * @return {PromiseLike<CryptoKey>}\n */\n\nexport const deriveKey = (secret, roomName) => {\n  const secretBuffer = string.encodeUtf8(secret).buffer;\n  const salt = string.encodeUtf8(roomName).buffer;\n  return crypto.subtle.importKey('raw', secretBuffer, 'PBKDF2', false, ['deriveKey']).then(keyMaterial => crypto.subtle.deriveKey({\n    name: 'PBKDF2',\n    salt,\n    iterations: 100000,\n    hash: 'SHA-256'\n  }, keyMaterial, {\n    name: 'AES-GCM',\n    length: 256\n  }, true, ['encrypt', 'decrypt']));\n};\n/**\n * @param {Uint8Array} data data to be encrypted\n * @param {CryptoKey?} key\n * @return {PromiseLike<Uint8Array>} encrypted, base64 encoded message\n */\n\nexport const encrypt = (data, key) => {\n  if (!key) {\n    return (\n      /** @type {PromiseLike<Uint8Array>} */\n      promise.resolve(data)\n    );\n  }\n\n  const iv = crypto.getRandomValues(new Uint8Array(12));\n  return crypto.subtle.encrypt({\n    name: 'AES-GCM',\n    iv\n  }, key, data).then(cipher => {\n    const encryptedDataEncoder = encoding.createEncoder();\n    encoding.writeVarString(encryptedDataEncoder, 'AES-GCM');\n    encoding.writeVarUint8Array(encryptedDataEncoder, iv);\n    encoding.writeVarUint8Array(encryptedDataEncoder, new Uint8Array(cipher));\n    return encoding.toUint8Array(encryptedDataEncoder);\n  });\n};\n/**\n * @param {Object} data data to be encrypted\n * @param {CryptoKey?} key\n * @return {PromiseLike<Uint8Array>} encrypted data, if key is provided\n */\n\nexport const encryptJson = (data, key) => {\n  const dataEncoder = encoding.createEncoder();\n  encoding.writeAny(dataEncoder, data);\n  return encrypt(encoding.toUint8Array(dataEncoder), key);\n};\n/**\n * @param {Uint8Array} data\n * @param {CryptoKey?} key\n * @return {PromiseLike<Uint8Array>} decrypted buffer\n */\n\nexport const decrypt = (data, key) => {\n  if (!key) {\n    return (\n      /** @type {PromiseLike<Uint8Array>} */\n      promise.resolve(data)\n    );\n  }\n\n  const dataDecoder = decoding.createDecoder(data);\n  const algorithm = decoding.readVarString(dataDecoder);\n\n  if (algorithm !== 'AES-GCM') {\n    promise.reject(error.create('Unknown encryption algorithm'));\n  }\n\n  const iv = decoding.readVarUint8Array(dataDecoder);\n  const cipher = decoding.readVarUint8Array(dataDecoder);\n  return crypto.subtle.decrypt({\n    name: 'AES-GCM',\n    iv\n  }, key, cipher).then(data => new Uint8Array(data));\n};\n/**\n * @param {Uint8Array} data\n * @param {CryptoKey?} key\n * @return {PromiseLike<Object>} decrypted object\n */\n\nexport const decryptJson = (data, key) => decrypt(data, key).then(decryptedValue => decoding.readAny(decoding.createDecoder(new Uint8Array(decryptedValue))));","map":{"version":3,"sources":["/home/aksaakov/Projects/collaborative-editor/node_modules/y-webrtc/src/crypto.js"],"names":["encoding","decoding","promise","error","string","deriveKey","secret","roomName","secretBuffer","encodeUtf8","buffer","salt","crypto","subtle","importKey","then","keyMaterial","name","iterations","hash","length","encrypt","data","key","resolve","iv","getRandomValues","Uint8Array","cipher","encryptedDataEncoder","createEncoder","writeVarString","writeVarUint8Array","toUint8Array","encryptJson","dataEncoder","writeAny","decrypt","dataDecoder","createDecoder","algorithm","readVarString","reject","create","readVarUint8Array","decryptJson","decryptedValue","readAny"],"mappings":"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","sourcesContent":["/* eslint-env browser */\n\nimport * as encoding from 'lib0/encoding'\nimport * as decoding from 'lib0/decoding'\nimport * as promise from 'lib0/promise'\nimport * as error from 'lib0/error'\nimport * as string from 'lib0/string'\n\n/**\n * @param {string} secret\n * @param {string} roomName\n * @return {PromiseLike<CryptoKey>}\n */\nexport const deriveKey = (secret, roomName) => {\n  const secretBuffer = string.encodeUtf8(secret).buffer\n  const salt = string.encodeUtf8(roomName).buffer\n  return crypto.subtle.importKey(\n    'raw',\n    secretBuffer,\n    'PBKDF2',\n    false,\n    ['deriveKey']\n  ).then(keyMaterial =>\n    crypto.subtle.deriveKey(\n      {\n        name: 'PBKDF2',\n        salt,\n        iterations: 100000,\n        hash: 'SHA-256'\n      },\n      keyMaterial,\n      {\n        name: 'AES-GCM',\n        length: 256\n      },\n      true,\n      ['encrypt', 'decrypt']\n    )\n  )\n}\n\n/**\n * @param {Uint8Array} data data to be encrypted\n * @param {CryptoKey?} key\n * @return {PromiseLike<Uint8Array>} encrypted, base64 encoded message\n */\nexport const encrypt = (data, key) => {\n  if (!key) {\n    return /** @type {PromiseLike<Uint8Array>} */ (promise.resolve(data))\n  }\n  const iv = crypto.getRandomValues(new Uint8Array(12))\n  return crypto.subtle.encrypt(\n    {\n      name: 'AES-GCM',\n      iv\n    },\n    key,\n    data\n  ).then(cipher => {\n    const encryptedDataEncoder = encoding.createEncoder()\n    encoding.writeVarString(encryptedDataEncoder, 'AES-GCM')\n    encoding.writeVarUint8Array(encryptedDataEncoder, iv)\n    encoding.writeVarUint8Array(encryptedDataEncoder, new Uint8Array(cipher))\n    return encoding.toUint8Array(encryptedDataEncoder)\n  })\n}\n\n/**\n * @param {Object} data data to be encrypted\n * @param {CryptoKey?} key\n * @return {PromiseLike<Uint8Array>} encrypted data, if key is provided\n */\nexport const encryptJson = (data, key) => {\n  const dataEncoder = encoding.createEncoder()\n  encoding.writeAny(dataEncoder, data)\n  return encrypt(encoding.toUint8Array(dataEncoder), key)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {CryptoKey?} key\n * @return {PromiseLike<Uint8Array>} decrypted buffer\n */\nexport const decrypt = (data, key) => {\n  if (!key) {\n    return /** @type {PromiseLike<Uint8Array>} */ (promise.resolve(data))\n  }\n  const dataDecoder = decoding.createDecoder(data)\n  const algorithm = decoding.readVarString(dataDecoder)\n  if (algorithm !== 'AES-GCM') {\n    promise.reject(error.create('Unknown encryption algorithm'))\n  }\n  const iv = decoding.readVarUint8Array(dataDecoder)\n  const cipher = decoding.readVarUint8Array(dataDecoder)\n  return crypto.subtle.decrypt(\n    {\n      name: 'AES-GCM',\n      iv\n    },\n    key,\n    cipher\n  ).then(data => new Uint8Array(data))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {CryptoKey?} key\n * @return {PromiseLike<Object>} decrypted object\n */\nexport const decryptJson = (data, key) =>\n  decrypt(data, key).then(decryptedValue =>\n    decoding.readAny(decoding.createDecoder(new Uint8Array(decryptedValue)))\n  )\n"]},"metadata":{},"sourceType":"module"}