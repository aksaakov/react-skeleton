{"ast":null,"code":"import * as ws from 'lib0/websocket';\nimport * as map from 'lib0/map';\nimport * as error from 'lib0/error';\nimport * as random from 'lib0/random';\nimport * as encoding from 'lib0/encoding';\nimport * as decoding from 'lib0/decoding';\nimport { Observable } from 'lib0/observable';\nimport * as logging from 'lib0/logging';\nimport * as promise from 'lib0/promise';\nimport * as bc from 'lib0/broadcastchannel';\nimport * as buffer from 'lib0/buffer';\nimport * as math from 'lib0/math';\nimport { createMutex } from 'lib0/mutex';\nimport * as Y from 'yjs'; // eslint-disable-line\n\nimport Peer from 'simple-peer/simplepeer.min.js';\nimport * as syncProtocol from 'y-protocols/sync';\nimport * as awarenessProtocol from 'y-protocols/awareness';\nimport * as cryptoutils from './crypto.js';\nconst log = logging.createModuleLogger('y-webrtc');\nconst messageSync = 0;\nconst messageQueryAwareness = 3;\nconst messageAwareness = 1;\nconst messageBcPeerId = 4;\n/**\n * @type {Map<string, SignalingConn>}\n */\n\nconst signalingConns = new Map();\n/**\n * @type {Map<string,Room>}\n */\n\nconst rooms = new Map();\n/**\n * @param {Room} room\n */\n\nconst checkIsSynced = room => {\n  let synced = true;\n  room.webrtcConns.forEach(peer => {\n    if (!peer.synced) {\n      synced = false;\n    }\n  });\n\n  if (!synced && room.synced || synced && !room.synced) {\n    room.synced = synced;\n    room.provider.emit('synced', [{\n      synced\n    }]);\n    log('synced ', logging.BOLD, room.name, logging.UNBOLD, ' with all peers');\n  }\n};\n/**\n * @param {Room} room\n * @param {Uint8Array} buf\n * @param {function} syncedCallback\n * @return {encoding.Encoder?}\n */\n\n\nconst readMessage = (room, buf, syncedCallback) => {\n  const decoder = decoding.createDecoder(buf);\n  const encoder = encoding.createEncoder();\n  const messageType = decoding.readVarUint(decoder);\n\n  if (room === undefined) {\n    return null;\n  }\n\n  const awareness = room.awareness;\n  const doc = room.doc;\n  let sendReply = false;\n\n  switch (messageType) {\n    case messageSync:\n      {\n        encoding.writeVarUint(encoder, messageSync);\n        const syncMessageType = syncProtocol.readSyncMessage(decoder, encoder, doc, room);\n\n        if (syncMessageType === syncProtocol.messageYjsSyncStep2 && !room.synced) {\n          syncedCallback();\n        }\n\n        if (syncMessageType === syncProtocol.messageYjsSyncStep1) {\n          sendReply = true;\n        }\n\n        break;\n      }\n\n    case messageQueryAwareness:\n      encoding.writeVarUint(encoder, messageAwareness);\n      encoding.writeVarUint8Array(encoder, awarenessProtocol.encodeAwarenessUpdate(awareness, Array.from(awareness.getStates().keys())));\n      sendReply = true;\n      break;\n\n    case messageAwareness:\n      awarenessProtocol.applyAwarenessUpdate(awareness, decoding.readVarUint8Array(decoder), room);\n      break;\n\n    case messageBcPeerId:\n      {\n        const add = decoding.readUint8(decoder) === 1;\n        const peerName = decoding.readVarString(decoder);\n\n        if (peerName !== room.peerId && (room.bcConns.has(peerName) && !add || !room.bcConns.has(peerName) && add)) {\n          const removed = [];\n          const added = [];\n\n          if (add) {\n            room.bcConns.add(peerName);\n            added.push(peerName);\n          } else {\n            room.bcConns.delete(peerName);\n            removed.push(peerName);\n          }\n\n          room.provider.emit('peers', [{\n            added,\n            removed,\n            webrtcPeers: Array.from(room.webrtcConns.keys()),\n            bcPeers: Array.from(room.bcConns)\n          }]);\n          broadcastBcPeerId(room);\n        }\n\n        break;\n      }\n\n    default:\n      console.error('Unable to compute message');\n      return encoder;\n  }\n\n  if (!sendReply) {\n    // nothing has been written, no answer created\n    return null;\n  }\n\n  return encoder;\n};\n/**\n * @param {WebrtcConn} peerConn\n * @param {Uint8Array} buf\n * @return {encoding.Encoder?}\n */\n\n\nconst readPeerMessage = (peerConn, buf) => {\n  const room = peerConn.room;\n  log('received message from ', logging.BOLD, peerConn.remotePeerId, logging.GREY, ' (', room.name, ')', logging.UNBOLD, logging.UNCOLOR);\n  return readMessage(room, buf, () => {\n    peerConn.synced = true;\n    log('synced ', logging.BOLD, room.name, logging.UNBOLD, ' with ', logging.BOLD, peerConn.remotePeerId);\n    checkIsSynced(room);\n  });\n};\n/**\n * @param {WebrtcConn} webrtcConn\n * @param {encoding.Encoder} encoder\n */\n\n\nconst sendWebrtcConn = (webrtcConn, encoder) => {\n  log('send message to ', logging.BOLD, webrtcConn.remotePeerId, logging.UNBOLD, logging.GREY, ' (', webrtcConn.room.name, ')', logging.UNCOLOR);\n\n  try {\n    webrtcConn.peer.send(encoding.toUint8Array(encoder));\n  } catch (e) {}\n};\n/**\n * @param {Room} room\n * @param {Uint8Array} m\n */\n\n\nconst broadcastWebrtcConn = (room, m) => {\n  log('broadcast message in ', logging.BOLD, room.name, logging.UNBOLD);\n  room.webrtcConns.forEach(conn => {\n    try {\n      conn.peer.send(m);\n    } catch (e) {}\n  });\n};\n\nexport class WebrtcConn {\n  /**\n   * @param {SignalingConn} signalingConn\n   * @param {boolean} initiator\n   * @param {string} remotePeerId\n   * @param {Room} room\n   */\n  constructor(signalingConn, initiator, remotePeerId, room) {\n    log('establishing connection to ', logging.BOLD, remotePeerId);\n    this.room = room;\n    this.remotePeerId = remotePeerId;\n    this.closed = false;\n    this.connected = false;\n    this.synced = false;\n    /**\n     * @type {any}\n     */\n\n    this.peer = new Peer({\n      initiator,\n      ...room.provider.peerOpts\n    });\n    this.peer.on('signal', signal => {\n      publishSignalingMessage(signalingConn, room, {\n        to: remotePeerId,\n        from: room.peerId,\n        type: 'signal',\n        signal\n      });\n    });\n    this.peer.on('connect', () => {\n      log('connected to ', logging.BOLD, remotePeerId);\n      this.connected = true; // send sync step 1\n\n      const provider = room.provider;\n      const doc = provider.doc;\n      const awareness = room.awareness;\n      const encoder = encoding.createEncoder();\n      encoding.writeVarUint(encoder, messageSync);\n      syncProtocol.writeSyncStep1(encoder, doc);\n      sendWebrtcConn(this, encoder);\n      const awarenessStates = awareness.getStates();\n\n      if (awarenessStates.size > 0) {\n        const encoder = encoding.createEncoder();\n        encoding.writeVarUint(encoder, messageAwareness);\n        encoding.writeVarUint8Array(encoder, awarenessProtocol.encodeAwarenessUpdate(awareness, Array.from(awarenessStates.keys())));\n        sendWebrtcConn(this, encoder);\n      }\n    });\n    this.peer.on('close', () => {\n      this.connected = false;\n      this.closed = true;\n\n      if (room.webrtcConns.has(this.remotePeerId)) {\n        room.webrtcConns.delete(this.remotePeerId);\n        room.provider.emit('peers', [{\n          removed: [this.remotePeerId],\n          added: [],\n          webrtcPeers: Array.from(room.webrtcConns.keys()),\n          bcPeers: Array.from(room.bcConns)\n        }]);\n      }\n\n      checkIsSynced(room);\n      this.peer.destroy();\n      log('closed connection to ', logging.BOLD, remotePeerId);\n      announceSignalingInfo(room);\n    });\n    this.peer.on('error', err => {\n      log('Error in connection to ', logging.BOLD, remotePeerId, ': ', err);\n      announceSignalingInfo(room);\n    });\n    this.peer.on('data', data => {\n      const answer = readPeerMessage(this, data);\n\n      if (answer !== null) {\n        sendWebrtcConn(this, answer);\n      }\n    });\n  }\n\n  destroy() {\n    this.peer.destroy();\n  }\n\n}\n/**\n * @param {Room} room\n * @param {Uint8Array} m\n */\n\nconst broadcastBcMessage = (room, m) => cryptoutils.encrypt(m, room.key).then(data => room.mux(() => bc.publish(room.name, data)));\n/**\n * @param {Room} room\n * @param {Uint8Array} m\n */\n\n\nconst broadcastRoomMessage = (room, m) => {\n  if (room.bcconnected) {\n    broadcastBcMessage(room, m);\n  }\n\n  broadcastWebrtcConn(room, m);\n};\n/**\n * @param {Room} room\n */\n\n\nconst announceSignalingInfo = room => {\n  signalingConns.forEach(conn => {\n    // only subcribe if connection is established, otherwise the conn automatically subscribes to all rooms\n    if (conn.connected) {\n      conn.send({\n        type: 'subscribe',\n        topics: [room.name]\n      });\n\n      if (room.webrtcConns.size < room.provider.maxConns) {\n        publishSignalingMessage(conn, room, {\n          type: 'announce',\n          from: room.peerId\n        });\n      }\n    }\n  });\n};\n/**\n * @param {Room} room\n */\n\n\nconst broadcastBcPeerId = room => {\n  if (room.provider.filterBcConns) {\n    // broadcast peerId via broadcastchannel\n    const encoderPeerIdBc = encoding.createEncoder();\n    encoding.writeVarUint(encoderPeerIdBc, messageBcPeerId);\n    encoding.writeUint8(encoderPeerIdBc, 1);\n    encoding.writeVarString(encoderPeerIdBc, room.peerId);\n    broadcastBcMessage(room, encoding.toUint8Array(encoderPeerIdBc));\n  }\n};\n\nexport class Room {\n  /**\n   * @param {Y.Doc} doc\n   * @param {WebrtcProvider} provider\n   * @param {string} name\n   * @param {CryptoKey|null} key\n   */\n  constructor(doc, provider, name, key) {\n    /**\n     * Do not assume that peerId is unique. This is only meant for sending signaling messages.\n     *\n     * @type {string}\n     */\n    this.peerId = random.uuidv4();\n    this.doc = doc;\n    /**\n     * @type {awarenessProtocol.Awareness}\n     */\n\n    this.awareness = provider.awareness;\n    this.provider = provider;\n    this.synced = false;\n    this.name = name; // @todo make key secret by scoping\n\n    this.key = key;\n    /**\n     * @type {Map<string, WebrtcConn>}\n     */\n\n    this.webrtcConns = new Map();\n    /**\n     * @type {Set<string>}\n     */\n\n    this.bcConns = new Set();\n    this.mux = createMutex();\n    this.bcconnected = false;\n    /**\n     * @param {ArrayBuffer} data\n     */\n\n    this._bcSubscriber = data => cryptoutils.decrypt(new Uint8Array(data), key).then(m => this.mux(() => {\n      const reply = readMessage(this, m, () => {});\n\n      if (reply) {\n        broadcastBcMessage(this, encoding.toUint8Array(reply));\n      }\n    }));\n    /**\n     * Listens to Yjs updates and sends them to remote peers\n     *\n     * @param {Uint8Array} update\n     * @param {any} origin\n     */\n\n\n    this._docUpdateHandler = (update, origin) => {\n      const encoder = encoding.createEncoder();\n      encoding.writeVarUint(encoder, messageSync);\n      syncProtocol.writeUpdate(encoder, update);\n      broadcastRoomMessage(this, encoding.toUint8Array(encoder));\n    };\n    /**\n     * Listens to Awareness updates and sends them to remote peers\n     *\n     * @param {any} changed\n     * @param {any} origin\n     */\n\n\n    this._awarenessUpdateHandler = ({\n      added,\n      updated,\n      removed\n    }, origin) => {\n      const changedClients = added.concat(updated).concat(removed);\n      const encoderAwareness = encoding.createEncoder();\n      encoding.writeVarUint(encoderAwareness, messageAwareness);\n      encoding.writeVarUint8Array(encoderAwareness, awarenessProtocol.encodeAwarenessUpdate(this.awareness, changedClients));\n      broadcastRoomMessage(this, encoding.toUint8Array(encoderAwareness));\n    };\n\n    this.doc.on('update', this._docUpdateHandler);\n    this.awareness.on('update', this._awarenessUpdateHandler);\n    window.addEventListener('beforeunload', () => {\n      awarenessProtocol.removeAwarenessStates(this.awareness, [doc.clientID], 'window unload');\n      rooms.forEach(room => {\n        room.disconnect();\n      });\n    });\n  }\n\n  connect() {\n    // signal through all available signaling connections\n    announceSignalingInfo(this);\n    const roomName = this.name;\n    bc.subscribe(roomName, this._bcSubscriber);\n    this.bcconnected = true; // broadcast peerId via broadcastchannel\n\n    broadcastBcPeerId(this); // write sync step 1\n\n    const encoderSync = encoding.createEncoder();\n    encoding.writeVarUint(encoderSync, messageSync);\n    syncProtocol.writeSyncStep1(encoderSync, this.doc);\n    broadcastBcMessage(this, encoding.toUint8Array(encoderSync)); // broadcast local state\n\n    const encoderState = encoding.createEncoder();\n    encoding.writeVarUint(encoderState, messageSync);\n    syncProtocol.writeSyncStep2(encoderState, this.doc);\n    broadcastBcMessage(this, encoding.toUint8Array(encoderState)); // write queryAwareness\n\n    const encoderAwarenessQuery = encoding.createEncoder();\n    encoding.writeVarUint(encoderAwarenessQuery, messageQueryAwareness);\n    broadcastBcMessage(this, encoding.toUint8Array(encoderAwarenessQuery)); // broadcast local awareness state\n\n    const encoderAwarenessState = encoding.createEncoder();\n    encoding.writeVarUint(encoderAwarenessState, messageAwareness);\n    encoding.writeVarUint8Array(encoderAwarenessState, awarenessProtocol.encodeAwarenessUpdate(this.awareness, [this.doc.clientID]));\n    broadcastBcMessage(this, encoding.toUint8Array(encoderAwarenessState));\n  }\n\n  disconnect() {\n    // signal through all available signaling connections\n    signalingConns.forEach(conn => {\n      if (conn.connected) {\n        conn.send({\n          type: 'unsubscribe',\n          topics: [this.name]\n        });\n      }\n    });\n    awarenessProtocol.removeAwarenessStates(this.awareness, [this.doc.clientID], 'disconnect'); // broadcast peerId removal via broadcastchannel\n\n    const encoderPeerIdBc = encoding.createEncoder();\n    encoding.writeVarUint(encoderPeerIdBc, messageBcPeerId);\n    encoding.writeUint8(encoderPeerIdBc, 0); // remove peerId from other bc peers\n\n    encoding.writeVarString(encoderPeerIdBc, this.peerId);\n    broadcastBcMessage(this, encoding.toUint8Array(encoderPeerIdBc));\n    bc.unsubscribe(this.name, this._bcSubscriber);\n    this.bcconnected = false;\n    this.doc.off('update', this._docUpdateHandler);\n    this.awareness.off('update', this._awarenessUpdateHandler);\n    this.webrtcConns.forEach(conn => conn.destroy());\n  }\n\n  destroy() {\n    this.disconnect();\n  }\n\n}\n/**\n * @param {Y.Doc} doc\n * @param {WebrtcProvider} provider\n * @param {string} name\n * @param {CryptoKey|null} key\n * @return {Room}\n */\n\nconst openRoom = (doc, provider, name, key) => {\n  // there must only be one room\n  if (rooms.has(name)) {\n    throw error.create(`A Yjs Doc connected to room \"${name}\" already exists!`);\n  }\n\n  const room = new Room(doc, provider, name, key);\n  rooms.set(name,\n  /** @type {Room} */\n  room);\n  return room;\n};\n/**\n * @param {SignalingConn} conn\n * @param {Room} room\n * @param {any} data\n */\n\n\nconst publishSignalingMessage = (conn, room, data) => {\n  if (room.key) {\n    cryptoutils.encryptJson(data, room.key).then(data => {\n      conn.send({\n        type: 'publish',\n        topic: room.name,\n        data: buffer.toBase64(data)\n      });\n    });\n  } else {\n    conn.send({\n      type: 'publish',\n      topic: room.name,\n      data\n    });\n  }\n};\n\nexport class SignalingConn extends ws.WebsocketClient {\n  constructor(url) {\n    super(url);\n    /**\n     * @type {Set<WebrtcProvider>}\n     */\n\n    this.providers = new Set();\n    this.on('connect', () => {\n      log(`connected (${url})`);\n      const topics = Array.from(rooms.keys());\n      this.send({\n        type: 'subscribe',\n        topics\n      });\n      rooms.forEach(room => publishSignalingMessage(this, room, {\n        type: 'announce',\n        from: room.peerId\n      }));\n    });\n    this.on('message', m => {\n      switch (m.type) {\n        case 'publish':\n          {\n            const roomName = m.topic;\n            const room = rooms.get(roomName);\n\n            if (room == null || typeof roomName !== 'string') {\n              return;\n            }\n\n            const execMessage = data => {\n              const webrtcConns = room.webrtcConns;\n              const peerId = room.peerId;\n\n              if (data == null || data.from === peerId || data.to !== undefined && data.to !== peerId || room.bcConns.has(data.from)) {\n                // ignore messages that are not addressed to this conn, or from clients that are connected via broadcastchannel\n                return;\n              }\n\n              const emitPeerChange = webrtcConns.has(data.from) ? () => {} : () => room.provider.emit('peers', [{\n                removed: [],\n                added: [data.from],\n                webrtcPeers: Array.from(room.webrtcConns.keys()),\n                bcPeers: Array.from(room.bcConns)\n              }]);\n\n              switch (data.type) {\n                case 'announce':\n                  if (webrtcConns.size < room.provider.maxConns) {\n                    map.setIfUndefined(webrtcConns, data.from, () => new WebrtcConn(this, true, data.from, room));\n                    emitPeerChange();\n                  }\n\n                  break;\n\n                case 'signal':\n                  if (data.to === peerId) {\n                    map.setIfUndefined(webrtcConns, data.from, () => new WebrtcConn(this, false, data.from, room)).peer.signal(data.signal);\n                    emitPeerChange();\n                  }\n\n                  break;\n              }\n            };\n\n            if (room.key) {\n              if (typeof m.data === 'string') {\n                cryptoutils.decryptJson(buffer.fromBase64(m.data), room.key).then(execMessage);\n              }\n            } else {\n              execMessage(m.data);\n            }\n          }\n      }\n    });\n    this.on('disconnect', () => log(`disconnect (${url})`));\n  }\n\n}\n/**\n * @extends Observable<string>\n */\n\nexport class WebrtcProvider extends Observable {\n  /**\n   * @param {string} roomName\n   * @param {Y.Doc} doc\n   * @param {Object} [opts]\n   * @param {Array<string>} [opts.signaling]\n   * @param {string?} [opts.password]\n   * @param {awarenessProtocol.Awareness} [opts.awareness]\n   * @param {number} [opts.maxConns]\n   * @param {boolean} [opts.filterBcConns]\n   * @param {any} [opts.peerOpts]\n   */\n  constructor(roomName, doc, {\n    signaling = ['wss://signaling.yjs.dev', 'wss://y-webrtc-signaling-eu.herokuapp.com', 'wss://y-webrtc-signaling-us.herokuapp.com'],\n    password = null,\n    awareness = new awarenessProtocol.Awareness(doc),\n    maxConns = 20 + math.floor(random.rand() * 15),\n    // the random factor reduces the chance that n clients form a cluster\n    filterBcConns = true,\n    peerOpts = {} // simple-peer options. See https://github.com/feross/simple-peer#peer--new-peeropts\n\n  } = {}) {\n    super();\n    this.roomName = roomName;\n    this.doc = doc;\n    this.filterBcConns = filterBcConns;\n    /**\n     * @type {awarenessProtocol.Awareness}\n     */\n\n    this.awareness = awareness;\n    this.shouldConnect = false;\n    this.signalingUrls = signaling;\n    this.signalingConns = [];\n    this.maxConns = maxConns;\n    this.peerOpts = peerOpts;\n    /**\n     * @type {PromiseLike<CryptoKey | null>}\n     */\n\n    this.key = password ? cryptoutils.deriveKey(password, roomName) :\n    /** @type {PromiseLike<null>} */\n    promise.resolve(null);\n    /**\n     * @type {Room|null}\n     */\n\n    this.room = null;\n    this.key.then(key => {\n      this.room = openRoom(doc, this, roomName, key);\n\n      if (this.shouldConnect) {\n        this.room.connect();\n      } else {\n        this.room.disconnect();\n      }\n    });\n    this.connect();\n    this.destroy = this.destroy.bind(this);\n    doc.on('destroy', this.destroy);\n  }\n  /**\n   * @type {boolean}\n   */\n\n\n  get connected() {\n    return this.room !== null && this.shouldConnect;\n  }\n\n  connect() {\n    this.shouldConnect = true;\n    this.signalingUrls.forEach(url => {\n      const signalingConn = map.setIfUndefined(signalingConns, url, () => new SignalingConn(url));\n      this.signalingConns.push(signalingConn);\n      signalingConn.providers.add(this);\n    });\n\n    if (this.room) {\n      this.room.connect();\n    }\n  }\n\n  disconnect() {\n    this.shouldConnect = false;\n    this.signalingConns.forEach(conn => {\n      conn.providers.delete(this);\n\n      if (conn.providers.size === 0) {\n        conn.destroy();\n        signalingConns.delete(conn.url);\n      }\n    });\n\n    if (this.room) {\n      this.room.disconnect();\n    }\n  }\n\n  destroy() {\n    this.doc.off('destroy', this.destroy); // need to wait for key before deleting room\n\n    this.key.then(() => {\n      /** @type {Room} */\n      this.room.destroy();\n      rooms.delete(this.roomName);\n    });\n    super.destroy();\n  }\n\n}","map":{"version":3,"sources":["/home/aksaakov/Projects/collaborative-editor/node_modules/y-webrtc/src/y-webrtc.js"],"names":["ws","map","error","random","encoding","decoding","Observable","logging","promise","bc","buffer","math","createMutex","Y","Peer","syncProtocol","awarenessProtocol","cryptoutils","log","createModuleLogger","messageSync","messageQueryAwareness","messageAwareness","messageBcPeerId","signalingConns","Map","rooms","checkIsSynced","room","synced","webrtcConns","forEach","peer","provider","emit","BOLD","name","UNBOLD","readMessage","buf","syncedCallback","decoder","createDecoder","encoder","createEncoder","messageType","readVarUint","undefined","awareness","doc","sendReply","writeVarUint","syncMessageType","readSyncMessage","messageYjsSyncStep2","messageYjsSyncStep1","writeVarUint8Array","encodeAwarenessUpdate","Array","from","getStates","keys","applyAwarenessUpdate","readVarUint8Array","add","readUint8","peerName","readVarString","peerId","bcConns","has","removed","added","push","delete","webrtcPeers","bcPeers","broadcastBcPeerId","console","readPeerMessage","peerConn","remotePeerId","GREY","UNCOLOR","sendWebrtcConn","webrtcConn","send","toUint8Array","e","broadcastWebrtcConn","m","conn","WebrtcConn","constructor","signalingConn","initiator","closed","connected","peerOpts","on","signal","publishSignalingMessage","to","type","writeSyncStep1","awarenessStates","size","destroy","announceSignalingInfo","err","data","answer","broadcastBcMessage","encrypt","key","then","mux","publish","broadcastRoomMessage","bcconnected","topics","maxConns","filterBcConns","encoderPeerIdBc","writeUint8","writeVarString","Room","uuidv4","Set","_bcSubscriber","decrypt","Uint8Array","reply","_docUpdateHandler","update","origin","writeUpdate","_awarenessUpdateHandler","updated","changedClients","concat","encoderAwareness","window","addEventListener","removeAwarenessStates","clientID","disconnect","connect","roomName","subscribe","encoderSync","encoderState","writeSyncStep2","encoderAwarenessQuery","encoderAwarenessState","unsubscribe","off","openRoom","create","set","encryptJson","topic","toBase64","SignalingConn","WebsocketClient","url","providers","get","execMessage","emitPeerChange","setIfUndefined","decryptJson","fromBase64","WebrtcProvider","signaling","password","Awareness","floor","rand","shouldConnect","signalingUrls","deriveKey","resolve","bind"],"mappings":"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","sourcesContent":["import * as ws from 'lib0/websocket'\nimport * as map from 'lib0/map'\nimport * as error from 'lib0/error'\nimport * as random from 'lib0/random'\nimport * as encoding from 'lib0/encoding'\nimport * as decoding from 'lib0/decoding'\nimport { Observable } from 'lib0/observable'\nimport * as logging from 'lib0/logging'\nimport * as promise from 'lib0/promise'\nimport * as bc from 'lib0/broadcastchannel'\nimport * as buffer from 'lib0/buffer'\nimport * as math from 'lib0/math'\nimport { createMutex } from 'lib0/mutex'\n\nimport * as Y from 'yjs' // eslint-disable-line\nimport Peer from 'simple-peer/simplepeer.min.js'\n\nimport * as syncProtocol from 'y-protocols/sync'\nimport * as awarenessProtocol from 'y-protocols/awareness'\n\nimport * as cryptoutils from './crypto.js'\n\nconst log = logging.createModuleLogger('y-webrtc')\n\nconst messageSync = 0\nconst messageQueryAwareness = 3\nconst messageAwareness = 1\nconst messageBcPeerId = 4\n\n/**\n * @type {Map<string, SignalingConn>}\n */\nconst signalingConns = new Map()\n\n/**\n * @type {Map<string,Room>}\n */\nconst rooms = new Map()\n\n/**\n * @param {Room} room\n */\nconst checkIsSynced = room => {\n  let synced = true\n  room.webrtcConns.forEach(peer => {\n    if (!peer.synced) {\n      synced = false\n    }\n  })\n  if ((!synced && room.synced) || (synced && !room.synced)) {\n    room.synced = synced\n    room.provider.emit('synced', [{ synced }])\n    log('synced ', logging.BOLD, room.name, logging.UNBOLD, ' with all peers')\n  }\n}\n\n/**\n * @param {Room} room\n * @param {Uint8Array} buf\n * @param {function} syncedCallback\n * @return {encoding.Encoder?}\n */\nconst readMessage = (room, buf, syncedCallback) => {\n  const decoder = decoding.createDecoder(buf)\n  const encoder = encoding.createEncoder()\n  const messageType = decoding.readVarUint(decoder)\n  if (room === undefined) {\n    return null\n  }\n  const awareness = room.awareness\n  const doc = room.doc\n  let sendReply = false\n  switch (messageType) {\n    case messageSync: {\n      encoding.writeVarUint(encoder, messageSync)\n      const syncMessageType = syncProtocol.readSyncMessage(decoder, encoder, doc, room)\n      if (syncMessageType === syncProtocol.messageYjsSyncStep2 && !room.synced) {\n        syncedCallback()\n      }\n      if (syncMessageType === syncProtocol.messageYjsSyncStep1) {\n        sendReply = true\n      }\n      break\n    }\n    case messageQueryAwareness:\n      encoding.writeVarUint(encoder, messageAwareness)\n      encoding.writeVarUint8Array(encoder, awarenessProtocol.encodeAwarenessUpdate(awareness, Array.from(awareness.getStates().keys())))\n      sendReply = true\n      break\n    case messageAwareness:\n      awarenessProtocol.applyAwarenessUpdate(awareness, decoding.readVarUint8Array(decoder), room)\n      break\n    case messageBcPeerId: {\n      const add = decoding.readUint8(decoder) === 1\n      const peerName = decoding.readVarString(decoder)\n      if (peerName !== room.peerId && ((room.bcConns.has(peerName) && !add) || (!room.bcConns.has(peerName) && add))) {\n        const removed = []\n        const added = []\n        if (add) {\n          room.bcConns.add(peerName)\n          added.push(peerName)\n        } else {\n          room.bcConns.delete(peerName)\n          removed.push(peerName)\n        }\n        room.provider.emit('peers', [{\n          added,\n          removed,\n          webrtcPeers: Array.from(room.webrtcConns.keys()),\n          bcPeers: Array.from(room.bcConns)\n        }])\n        broadcastBcPeerId(room)\n      }\n      break\n    }\n    default:\n      console.error('Unable to compute message')\n      return encoder\n  }\n  if (!sendReply) {\n    // nothing has been written, no answer created\n    return null\n  }\n  return encoder\n}\n\n/**\n * @param {WebrtcConn} peerConn\n * @param {Uint8Array} buf\n * @return {encoding.Encoder?}\n */\nconst readPeerMessage = (peerConn, buf) => {\n  const room = peerConn.room\n  log('received message from ', logging.BOLD, peerConn.remotePeerId, logging.GREY, ' (', room.name, ')', logging.UNBOLD, logging.UNCOLOR)\n  return readMessage(room, buf, () => {\n    peerConn.synced = true\n    log('synced ', logging.BOLD, room.name, logging.UNBOLD, ' with ', logging.BOLD, peerConn.remotePeerId)\n    checkIsSynced(room)\n  })\n}\n\n/**\n * @param {WebrtcConn} webrtcConn\n * @param {encoding.Encoder} encoder\n */\nconst sendWebrtcConn = (webrtcConn, encoder) => {\n  log('send message to ', logging.BOLD, webrtcConn.remotePeerId, logging.UNBOLD, logging.GREY, ' (', webrtcConn.room.name, ')', logging.UNCOLOR)\n  try {\n    webrtcConn.peer.send(encoding.toUint8Array(encoder))\n  } catch (e) {}\n}\n\n/**\n * @param {Room} room\n * @param {Uint8Array} m\n */\nconst broadcastWebrtcConn = (room, m) => {\n  log('broadcast message in ', logging.BOLD, room.name, logging.UNBOLD)\n  room.webrtcConns.forEach(conn => {\n    try {\n      conn.peer.send(m)\n    } catch (e) {}\n  })\n}\n\nexport class WebrtcConn {\n  /**\n   * @param {SignalingConn} signalingConn\n   * @param {boolean} initiator\n   * @param {string} remotePeerId\n   * @param {Room} room\n   */\n  constructor (signalingConn, initiator, remotePeerId, room) {\n    log('establishing connection to ', logging.BOLD, remotePeerId)\n    this.room = room\n    this.remotePeerId = remotePeerId\n    this.closed = false\n    this.connected = false\n    this.synced = false\n    /**\n     * @type {any}\n     */\n    this.peer = new Peer({ initiator, ...room.provider.peerOpts })\n    this.peer.on('signal', signal => {\n      publishSignalingMessage(signalingConn, room, { to: remotePeerId, from: room.peerId, type: 'signal', signal })\n    })\n    this.peer.on('connect', () => {\n      log('connected to ', logging.BOLD, remotePeerId)\n      this.connected = true\n      // send sync step 1\n      const provider = room.provider\n      const doc = provider.doc\n      const awareness = room.awareness\n      const encoder = encoding.createEncoder()\n      encoding.writeVarUint(encoder, messageSync)\n      syncProtocol.writeSyncStep1(encoder, doc)\n      sendWebrtcConn(this, encoder)\n      const awarenessStates = awareness.getStates()\n      if (awarenessStates.size > 0) {\n        const encoder = encoding.createEncoder()\n        encoding.writeVarUint(encoder, messageAwareness)\n        encoding.writeVarUint8Array(encoder, awarenessProtocol.encodeAwarenessUpdate(awareness, Array.from(awarenessStates.keys())))\n        sendWebrtcConn(this, encoder)\n      }\n    })\n    this.peer.on('close', () => {\n      this.connected = false\n      this.closed = true\n      if (room.webrtcConns.has(this.remotePeerId)) {\n        room.webrtcConns.delete(this.remotePeerId)\n        room.provider.emit('peers', [{\n          removed: [this.remotePeerId],\n          added: [],\n          webrtcPeers: Array.from(room.webrtcConns.keys()),\n          bcPeers: Array.from(room.bcConns)\n        }])\n      }\n      checkIsSynced(room)\n      this.peer.destroy()\n      log('closed connection to ', logging.BOLD, remotePeerId)\n      announceSignalingInfo(room)\n    })\n    this.peer.on('error', err => {\n      log('Error in connection to ', logging.BOLD, remotePeerId, ': ', err)\n      announceSignalingInfo(room)\n    })\n    this.peer.on('data', data => {\n      const answer = readPeerMessage(this, data)\n      if (answer !== null) {\n        sendWebrtcConn(this, answer)\n      }\n    })\n  }\n\n  destroy () {\n    this.peer.destroy()\n  }\n}\n\n/**\n * @param {Room} room\n * @param {Uint8Array} m\n */\nconst broadcastBcMessage = (room, m) => cryptoutils.encrypt(m, room.key).then(data =>\n  room.mux(() =>\n    bc.publish(room.name, data)\n  )\n)\n\n/**\n * @param {Room} room\n * @param {Uint8Array} m\n */\nconst broadcastRoomMessage = (room, m) => {\n  if (room.bcconnected) {\n    broadcastBcMessage(room, m)\n  }\n  broadcastWebrtcConn(room, m)\n}\n\n/**\n * @param {Room} room\n */\nconst announceSignalingInfo = room => {\n  signalingConns.forEach(conn => {\n    // only subcribe if connection is established, otherwise the conn automatically subscribes to all rooms\n    if (conn.connected) {\n      conn.send({ type: 'subscribe', topics: [room.name] })\n      if (room.webrtcConns.size < room.provider.maxConns) {\n        publishSignalingMessage(conn, room, { type: 'announce', from: room.peerId })\n      }\n    }\n  })\n}\n\n/**\n * @param {Room} room\n */\nconst broadcastBcPeerId = room => {\n  if (room.provider.filterBcConns) {\n    // broadcast peerId via broadcastchannel\n    const encoderPeerIdBc = encoding.createEncoder()\n    encoding.writeVarUint(encoderPeerIdBc, messageBcPeerId)\n    encoding.writeUint8(encoderPeerIdBc, 1)\n    encoding.writeVarString(encoderPeerIdBc, room.peerId)\n    broadcastBcMessage(room, encoding.toUint8Array(encoderPeerIdBc))\n  }\n}\n\nexport class Room {\n  /**\n   * @param {Y.Doc} doc\n   * @param {WebrtcProvider} provider\n   * @param {string} name\n   * @param {CryptoKey|null} key\n   */\n  constructor (doc, provider, name, key) {\n    /**\n     * Do not assume that peerId is unique. This is only meant for sending signaling messages.\n     *\n     * @type {string}\n     */\n    this.peerId = random.uuidv4()\n    this.doc = doc\n    /**\n     * @type {awarenessProtocol.Awareness}\n     */\n    this.awareness = provider.awareness\n    this.provider = provider\n    this.synced = false\n    this.name = name\n    // @todo make key secret by scoping\n    this.key = key\n    /**\n     * @type {Map<string, WebrtcConn>}\n     */\n    this.webrtcConns = new Map()\n    /**\n     * @type {Set<string>}\n     */\n    this.bcConns = new Set()\n    this.mux = createMutex()\n    this.bcconnected = false\n    /**\n     * @param {ArrayBuffer} data\n     */\n    this._bcSubscriber = data =>\n      cryptoutils.decrypt(new Uint8Array(data), key).then(m =>\n        this.mux(() => {\n          const reply = readMessage(this, m, () => {})\n          if (reply) {\n            broadcastBcMessage(this, encoding.toUint8Array(reply))\n          }\n        })\n      )\n    /**\n     * Listens to Yjs updates and sends them to remote peers\n     *\n     * @param {Uint8Array} update\n     * @param {any} origin\n     */\n    this._docUpdateHandler = (update, origin) => {\n      const encoder = encoding.createEncoder()\n      encoding.writeVarUint(encoder, messageSync)\n      syncProtocol.writeUpdate(encoder, update)\n      broadcastRoomMessage(this, encoding.toUint8Array(encoder))\n    }\n    /**\n     * Listens to Awareness updates and sends them to remote peers\n     *\n     * @param {any} changed\n     * @param {any} origin\n     */\n    this._awarenessUpdateHandler = ({ added, updated, removed }, origin) => {\n      const changedClients = added.concat(updated).concat(removed)\n      const encoderAwareness = encoding.createEncoder()\n      encoding.writeVarUint(encoderAwareness, messageAwareness)\n      encoding.writeVarUint8Array(encoderAwareness, awarenessProtocol.encodeAwarenessUpdate(this.awareness, changedClients))\n      broadcastRoomMessage(this, encoding.toUint8Array(encoderAwareness))\n    }\n    this.doc.on('update', this._docUpdateHandler)\n    this.awareness.on('update', this._awarenessUpdateHandler)\n    window.addEventListener('beforeunload', () => {\n      awarenessProtocol.removeAwarenessStates(this.awareness, [doc.clientID], 'window unload')\n      rooms.forEach(room => {\n        room.disconnect()\n      })\n    })\n  }\n\n  connect () {\n    // signal through all available signaling connections\n    announceSignalingInfo(this)\n    const roomName = this.name\n    bc.subscribe(roomName, this._bcSubscriber)\n    this.bcconnected = true\n    // broadcast peerId via broadcastchannel\n    broadcastBcPeerId(this)\n    // write sync step 1\n    const encoderSync = encoding.createEncoder()\n    encoding.writeVarUint(encoderSync, messageSync)\n    syncProtocol.writeSyncStep1(encoderSync, this.doc)\n    broadcastBcMessage(this, encoding.toUint8Array(encoderSync))\n    // broadcast local state\n    const encoderState = encoding.createEncoder()\n    encoding.writeVarUint(encoderState, messageSync)\n    syncProtocol.writeSyncStep2(encoderState, this.doc)\n    broadcastBcMessage(this, encoding.toUint8Array(encoderState))\n    // write queryAwareness\n    const encoderAwarenessQuery = encoding.createEncoder()\n    encoding.writeVarUint(encoderAwarenessQuery, messageQueryAwareness)\n    broadcastBcMessage(this, encoding.toUint8Array(encoderAwarenessQuery))\n    // broadcast local awareness state\n    const encoderAwarenessState = encoding.createEncoder()\n    encoding.writeVarUint(encoderAwarenessState, messageAwareness)\n    encoding.writeVarUint8Array(encoderAwarenessState, awarenessProtocol.encodeAwarenessUpdate(this.awareness, [this.doc.clientID]))\n    broadcastBcMessage(this, encoding.toUint8Array(encoderAwarenessState))\n  }\n\n  disconnect () {\n    // signal through all available signaling connections\n    signalingConns.forEach(conn => {\n      if (conn.connected) {\n        conn.send({ type: 'unsubscribe', topics: [this.name] })\n      }\n    })\n    awarenessProtocol.removeAwarenessStates(this.awareness, [this.doc.clientID], 'disconnect')\n    // broadcast peerId removal via broadcastchannel\n    const encoderPeerIdBc = encoding.createEncoder()\n    encoding.writeVarUint(encoderPeerIdBc, messageBcPeerId)\n    encoding.writeUint8(encoderPeerIdBc, 0) // remove peerId from other bc peers\n    encoding.writeVarString(encoderPeerIdBc, this.peerId)\n    broadcastBcMessage(this, encoding.toUint8Array(encoderPeerIdBc))\n\n    bc.unsubscribe(this.name, this._bcSubscriber)\n    this.bcconnected = false\n    this.doc.off('update', this._docUpdateHandler)\n    this.awareness.off('update', this._awarenessUpdateHandler)\n    this.webrtcConns.forEach(conn => conn.destroy())\n  }\n\n  destroy () {\n    this.disconnect()\n  }\n}\n\n/**\n * @param {Y.Doc} doc\n * @param {WebrtcProvider} provider\n * @param {string} name\n * @param {CryptoKey|null} key\n * @return {Room}\n */\nconst openRoom = (doc, provider, name, key) => {\n  // there must only be one room\n  if (rooms.has(name)) {\n    throw error.create(`A Yjs Doc connected to room \"${name}\" already exists!`)\n  }\n  const room = new Room(doc, provider, name, key)\n  rooms.set(name, /** @type {Room} */ (room))\n  return room\n}\n\n/**\n * @param {SignalingConn} conn\n * @param {Room} room\n * @param {any} data\n */\nconst publishSignalingMessage = (conn, room, data) => {\n  if (room.key) {\n    cryptoutils.encryptJson(data, room.key).then(data => {\n      conn.send({ type: 'publish', topic: room.name, data: buffer.toBase64(data) })\n    })\n  } else {\n    conn.send({ type: 'publish', topic: room.name, data })\n  }\n}\n\nexport class SignalingConn extends ws.WebsocketClient {\n  constructor (url) {\n    super(url)\n    /**\n     * @type {Set<WebrtcProvider>}\n     */\n    this.providers = new Set()\n    this.on('connect', () => {\n      log(`connected (${url})`)\n      const topics = Array.from(rooms.keys())\n      this.send({ type: 'subscribe', topics })\n      rooms.forEach(room =>\n        publishSignalingMessage(this, room, { type: 'announce', from: room.peerId })\n      )\n    })\n    this.on('message', m => {\n      switch (m.type) {\n        case 'publish': {\n          const roomName = m.topic\n          const room = rooms.get(roomName)\n          if (room == null || typeof roomName !== 'string') {\n            return\n          }\n          const execMessage = data => {\n            const webrtcConns = room.webrtcConns\n            const peerId = room.peerId\n            if (data == null || data.from === peerId || (data.to !== undefined && data.to !== peerId) || room.bcConns.has(data.from)) {\n              // ignore messages that are not addressed to this conn, or from clients that are connected via broadcastchannel\n              return\n            }\n            const emitPeerChange = webrtcConns.has(data.from) ? () => {} : () =>\n              room.provider.emit('peers', [{\n                removed: [],\n                added: [data.from],\n                webrtcPeers: Array.from(room.webrtcConns.keys()),\n                bcPeers: Array.from(room.bcConns)\n              }])\n            switch (data.type) {\n              case 'announce':\n                if (webrtcConns.size < room.provider.maxConns) {\n                  map.setIfUndefined(webrtcConns, data.from, () => new WebrtcConn(this, true, data.from, room))\n                  emitPeerChange()\n                }\n                break\n              case 'signal':\n                if (data.to === peerId) {\n                  map.setIfUndefined(webrtcConns, data.from, () => new WebrtcConn(this, false, data.from, room)).peer.signal(data.signal)\n                  emitPeerChange()\n                }\n                break\n            }\n          }\n          if (room.key) {\n            if (typeof m.data === 'string') {\n              cryptoutils.decryptJson(buffer.fromBase64(m.data), room.key).then(execMessage)\n            }\n          } else {\n            execMessage(m.data)\n          }\n        }\n      }\n    })\n    this.on('disconnect', () => log(`disconnect (${url})`))\n  }\n}\n\n/**\n * @extends Observable<string>\n */\nexport class WebrtcProvider extends Observable {\n  /**\n   * @param {string} roomName\n   * @param {Y.Doc} doc\n   * @param {Object} [opts]\n   * @param {Array<string>} [opts.signaling]\n   * @param {string?} [opts.password]\n   * @param {awarenessProtocol.Awareness} [opts.awareness]\n   * @param {number} [opts.maxConns]\n   * @param {boolean} [opts.filterBcConns]\n   * @param {any} [opts.peerOpts]\n   */\n  constructor (\n    roomName,\n    doc,\n    {\n      signaling = ['wss://signaling.yjs.dev', 'wss://y-webrtc-signaling-eu.herokuapp.com', 'wss://y-webrtc-signaling-us.herokuapp.com'],\n      password = null,\n      awareness = new awarenessProtocol.Awareness(doc),\n      maxConns = 20 + math.floor(random.rand() * 15), // the random factor reduces the chance that n clients form a cluster\n      filterBcConns = true,\n      peerOpts = {} // simple-peer options. See https://github.com/feross/simple-peer#peer--new-peeropts\n    } = {}\n  ) {\n    super()\n    this.roomName = roomName\n    this.doc = doc\n    this.filterBcConns = filterBcConns\n    /**\n     * @type {awarenessProtocol.Awareness}\n     */\n    this.awareness = awareness\n    this.shouldConnect = false\n    this.signalingUrls = signaling\n    this.signalingConns = []\n    this.maxConns = maxConns\n    this.peerOpts = peerOpts\n    /**\n     * @type {PromiseLike<CryptoKey | null>}\n     */\n    this.key = password ? cryptoutils.deriveKey(password, roomName) : /** @type {PromiseLike<null>} */ (promise.resolve(null))\n    /**\n     * @type {Room|null}\n     */\n    this.room = null\n    this.key.then(key => {\n      this.room = openRoom(doc, this, roomName, key)\n      if (this.shouldConnect) {\n        this.room.connect()\n      } else {\n        this.room.disconnect()\n      }\n    })\n    this.connect()\n    this.destroy = this.destroy.bind(this)\n    doc.on('destroy', this.destroy)\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get connected () {\n    return this.room !== null && this.shouldConnect\n  }\n\n  connect () {\n    this.shouldConnect = true\n    this.signalingUrls.forEach(url => {\n      const signalingConn = map.setIfUndefined(signalingConns, url, () => new SignalingConn(url))\n      this.signalingConns.push(signalingConn)\n      signalingConn.providers.add(this)\n    })\n    if (this.room) {\n      this.room.connect()\n    }\n  }\n\n  disconnect () {\n    this.shouldConnect = false\n    this.signalingConns.forEach(conn => {\n      conn.providers.delete(this)\n      if (conn.providers.size === 0) {\n        conn.destroy()\n        signalingConns.delete(conn.url)\n      }\n    })\n    if (this.room) {\n      this.room.disconnect()\n    }\n  }\n\n  destroy () {\n    this.doc.off('destroy', this.destroy)\n    // need to wait for key before deleting room\n    this.key.then(() => {\n      /** @type {Room} */ (this.room).destroy()\n      rooms.delete(this.roomName)\n    })\n    super.destroy()\n  }\n}\n"]},"metadata":{},"sourceType":"module"}