{"ast":null,"code":"import * as Y from 'yjs';\nimport * as idb from 'lib0/indexeddb.js';\nimport * as mutex from 'lib0/mutex.js';\nimport { Observable } from 'lib0/observable.js';\nconst customStoreName = 'custom';\nconst updatesStoreName = 'updates';\nexport const PREFERRED_TRIM_SIZE = 500;\n/**\n * @param {IndexeddbPersistence} idbPersistence\n */\n\nexport const fetchUpdates = idbPersistence => {\n  const [updatesStore] = idb.transact(\n  /** @type {IDBDatabase} */\n  idbPersistence.db, [updatesStoreName]); // , 'readonly')\n\n  return idb.getAll(updatesStore, idb.createIDBKeyRangeLowerBound(idbPersistence._dbref, false)).then(updates => idbPersistence._mux(() => idbPersistence.doc.transact(() => updates.forEach(val => Y.applyUpdate(idbPersistence.doc, val))))).then(() => idb.getLastKey(updatesStore).then(lastKey => {\n    idbPersistence._dbref = lastKey + 1;\n  })).then(() => idb.count(updatesStore).then(cnt => {\n    idbPersistence._dbsize = cnt;\n  })).then(() => updatesStore);\n};\n/**\n * @param {IndexeddbPersistence} idbPersistence\n * @param {boolean} forceStore\n */\n\nexport const storeState = (idbPersistence, forceStore = true) => fetchUpdates(idbPersistence).then(updatesStore => {\n  if (forceStore || idbPersistence._dbsize >= PREFERRED_TRIM_SIZE) {\n    idb.addAutoKey(updatesStore, Y.encodeStateAsUpdate(idbPersistence.doc)).then(() => idb.del(updatesStore, idb.createIDBKeyRangeUpperBound(idbPersistence._dbref, true))).then(() => idb.count(updatesStore).then(cnt => {\n      idbPersistence._dbsize = cnt;\n    }));\n  }\n});\n/**\n * @param {string} name\n */\n\nexport const clearDocument = name => idb.deleteDB(name);\n/**\n * @extends Observable<string>\n */\n\nexport class IndexeddbPersistence extends Observable {\n  /**\n   * @param {string} name\n   * @param {Y.Doc} doc\n   */\n  constructor(name, doc) {\n    super();\n    this.doc = doc;\n    this.name = name;\n    this._mux = mutex.createMutex();\n    this._dbref = 0;\n    this._dbsize = 0;\n    /**\n     * @type {IDBDatabase|null}\n     */\n\n    this.db = null;\n    this.synced = false;\n    this._db = idb.openDB(name, db => idb.createStores(db, [['updates', {\n      autoIncrement: true\n    }], ['custom']]));\n    /**\n     * @type {Promise<IndexeddbPersistence>}\n     */\n\n    this.whenSynced = this._db.then(db => {\n      this.db = db;\n      const currState = Y.encodeStateAsUpdate(doc);\n      return fetchUpdates(this).then(updatesStore => idb.addAutoKey(updatesStore, currState)).then(() => {\n        this.emit('synced', [this]);\n        this.synced = true;\n        return this;\n      });\n    });\n    /**\n     * Timeout in ms untill data is merged and persisted in idb.\n     */\n\n    this._storeTimeout = 1000;\n    /**\n     * @type {any}\n     */\n\n    this._storeTimeoutId = null;\n    /**\n     * @param {Uint8Array} update\n     */\n\n    this._storeUpdate = update => this._mux(() => {\n      if (this.db) {\n        const [updatesStore] = idb.transact(\n        /** @type {IDBDatabase} */\n        this.db, [updatesStoreName]);\n        idb.addAutoKey(updatesStore, update);\n\n        if (++this._dbsize >= PREFERRED_TRIM_SIZE) {\n          // debounce store call\n          if (this._storeTimeoutId !== null) {\n            clearTimeout(this._storeTimeoutId);\n          }\n\n          this._storeTimeoutId = setTimeout(() => {\n            storeState(this, false);\n            this._storeTimeoutId = null;\n          }, this._storeTimeout);\n        }\n      }\n    });\n\n    doc.on('update', this._storeUpdate);\n    this.destroy = this.destroy.bind(this);\n    doc.on('destroy', this.destroy);\n  }\n\n  destroy() {\n    if (this._storeTimeoutId) {\n      clearTimeout(this._storeTimeoutId);\n    }\n\n    this.doc.off('update', this._storeUpdate);\n    this.doc.off('destroy', this.destroy);\n    return this._db.then(db => {\n      db.close();\n    });\n  }\n  /**\n   * Destroys this instance and removes all data from indexeddb.\n   *\n   * @return {Promise<void>}\n   */\n\n\n  clearData() {\n    return this.destroy().then(() => {\n      idb.deleteDB(this.name);\n    });\n  }\n  /**\n   * @param {String | number | ArrayBuffer | Date} key\n   * @return {Promise<String | number | ArrayBuffer | Date | any>}\n   */\n\n\n  get(key) {\n    return this._db.then(db => {\n      const [custom] = idb.transact(db, [customStoreName], 'readonly');\n      return idb.get(custom, key);\n    });\n  }\n  /**\n   * @param {String | number | ArrayBuffer | Date} key\n   * @param {String | number | ArrayBuffer | Date} value\n   * @return {Promise<String | number | ArrayBuffer | Date>}\n   */\n\n\n  set(key, value) {\n    return this._db.then(db => {\n      const [custom] = idb.transact(db, [customStoreName]);\n      return idb.put(custom, value, key);\n    });\n  }\n  /**\n   * @param {String | number | ArrayBuffer | Date} key\n   * @return {Promise<undefined>}\n   */\n\n\n  del(key) {\n    return this._db.then(db => {\n      const [custom] = idb.transact(db, [customStoreName]);\n      return idb.del(custom, key);\n    });\n  }\n\n}","map":{"version":3,"sources":["/home/aksaakov/Projects/collaborative-editor/node_modules/y-indexeddb/src/y-indexeddb.js"],"names":["Y","idb","mutex","Observable","customStoreName","updatesStoreName","PREFERRED_TRIM_SIZE","fetchUpdates","idbPersistence","updatesStore","transact","db","getAll","createIDBKeyRangeLowerBound","_dbref","then","updates","_mux","doc","forEach","val","applyUpdate","getLastKey","lastKey","count","cnt","_dbsize","storeState","forceStore","addAutoKey","encodeStateAsUpdate","del","createIDBKeyRangeUpperBound","clearDocument","name","deleteDB","IndexeddbPersistence","constructor","createMutex","synced","_db","openDB","createStores","autoIncrement","whenSynced","currState","emit","_storeTimeout","_storeTimeoutId","_storeUpdate","update","clearTimeout","setTimeout","on","destroy","bind","off","close","clearData","get","key","custom","set","value","put"],"mappings":"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","sourcesContent":["import * as Y from 'yjs'\nimport * as idb from 'lib0/indexeddb.js'\nimport * as mutex from 'lib0/mutex.js'\nimport { Observable } from 'lib0/observable.js'\n\nconst customStoreName = 'custom'\nconst updatesStoreName = 'updates'\n\nexport const PREFERRED_TRIM_SIZE = 500\n\n/**\n * @param {IndexeddbPersistence} idbPersistence\n */\nexport const fetchUpdates = idbPersistence => {\n  const [updatesStore] = idb.transact(/** @type {IDBDatabase} */ (idbPersistence.db), [updatesStoreName]) // , 'readonly')\n  return idb.getAll(updatesStore, idb.createIDBKeyRangeLowerBound(idbPersistence._dbref, false)).then(updates =>\n    idbPersistence._mux(() =>\n      idbPersistence.doc.transact(() =>\n        updates.forEach(val => Y.applyUpdate(idbPersistence.doc, val))\n      )\n    )\n  )\n    .then(() => idb.getLastKey(updatesStore).then(lastKey => { idbPersistence._dbref = lastKey + 1 }))\n    .then(() => idb.count(updatesStore).then(cnt => { idbPersistence._dbsize = cnt }))\n    .then(() => updatesStore)\n}\n\n/**\n * @param {IndexeddbPersistence} idbPersistence\n * @param {boolean} forceStore\n */\nexport const storeState = (idbPersistence, forceStore = true) =>\n  fetchUpdates(idbPersistence)\n    .then(updatesStore => {\n      if (forceStore || idbPersistence._dbsize >= PREFERRED_TRIM_SIZE) {\n        idb.addAutoKey(updatesStore, Y.encodeStateAsUpdate(idbPersistence.doc))\n          .then(() => idb.del(updatesStore, idb.createIDBKeyRangeUpperBound(idbPersistence._dbref, true)))\n          .then(() => idb.count(updatesStore).then(cnt => { idbPersistence._dbsize = cnt }))\n      }\n    })\n\n/**\n * @param {string} name\n */\nexport const clearDocument = name => idb.deleteDB(name)\n\n/**\n * @extends Observable<string>\n */\nexport class IndexeddbPersistence extends Observable {\n  /**\n   * @param {string} name\n   * @param {Y.Doc} doc\n   */\n  constructor (name, doc) {\n    super()\n    this.doc = doc\n    this.name = name\n    this._mux = mutex.createMutex()\n    this._dbref = 0\n    this._dbsize = 0\n    /**\n     * @type {IDBDatabase|null}\n     */\n    this.db = null\n    this.synced = false\n    this._db = idb.openDB(name, db =>\n      idb.createStores(db, [\n        ['updates', { autoIncrement: true }],\n        ['custom']\n      ])\n    )\n    /**\n     * @type {Promise<IndexeddbPersistence>}\n     */\n    this.whenSynced = this._db.then(db => {\n      this.db = db\n      const currState = Y.encodeStateAsUpdate(doc)\n      return fetchUpdates(this).then(updatesStore => idb.addAutoKey(updatesStore, currState)).then(() => {\n        this.emit('synced', [this])\n        this.synced = true\n        return this\n      })\n    })\n    /**\n     * Timeout in ms untill data is merged and persisted in idb.\n     */\n    this._storeTimeout = 1000\n    /**\n     * @type {any}\n     */\n    this._storeTimeoutId = null\n    /**\n     * @param {Uint8Array} update\n     */\n    this._storeUpdate = update =>\n      this._mux(() => {\n        if (this.db) {\n          const [updatesStore] = idb.transact(/** @type {IDBDatabase} */ (this.db), [updatesStoreName])\n          idb.addAutoKey(updatesStore, update)\n          if (++this._dbsize >= PREFERRED_TRIM_SIZE) {\n            // debounce store call\n            if (this._storeTimeoutId !== null) {\n              clearTimeout(this._storeTimeoutId)\n            }\n            this._storeTimeoutId = setTimeout(() => {\n              storeState(this, false)\n              this._storeTimeoutId = null\n            }, this._storeTimeout)\n          }\n        }\n      })\n    doc.on('update', this._storeUpdate)\n    this.destroy = this.destroy.bind(this)\n    doc.on('destroy', this.destroy)\n  }\n\n  destroy () {\n    if (this._storeTimeoutId) {\n      clearTimeout(this._storeTimeoutId)\n    }\n    this.doc.off('update', this._storeUpdate)\n    this.doc.off('destroy', this.destroy)\n    return this._db.then(db => {\n      db.close()\n    })\n  }\n\n  /**\n   * Destroys this instance and removes all data from indexeddb.\n   *\n   * @return {Promise<void>}\n   */\n  clearData () {\n    return this.destroy().then(() => {\n      idb.deleteDB(this.name)\n    })\n  }\n\n  /**\n   * @param {String | number | ArrayBuffer | Date} key\n   * @return {Promise<String | number | ArrayBuffer | Date | any>}\n   */\n  get (key) {\n    return this._db.then(db => {\n      const [custom] = idb.transact(db, [customStoreName], 'readonly')\n      return idb.get(custom, key)\n    })\n  }\n\n  /**\n   * @param {String | number | ArrayBuffer | Date} key\n   * @param {String | number | ArrayBuffer | Date} value\n   * @return {Promise<String | number | ArrayBuffer | Date>}\n   */\n  set (key, value) {\n    return this._db.then(db => {\n      const [custom] = idb.transact(db, [customStoreName])\n      return idb.put(custom, value, key)\n    })\n  }\n\n  /**\n   * @param {String | number | ArrayBuffer | Date} key\n   * @return {Promise<undefined>}\n   */\n  del (key) {\n    return this._db.then(db => {\n      const [custom] = idb.transact(db, [customStoreName])\n      return idb.del(custom, key)\n    })\n  }\n}\n"]},"metadata":{},"sourceType":"module"}