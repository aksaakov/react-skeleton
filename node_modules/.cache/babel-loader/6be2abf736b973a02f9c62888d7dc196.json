{"ast":null,"code":"/* eslint-env browser */\n\n/**\n * Helpers to work with IndexedDB.\n *\n * @module idb\n */\nimport * as promise from './promise.js';\nimport * as error from './error.js';\n/**\n * IDB Request to Promise transformer\n *\n * @param {IDBRequest} request\n * @return {Promise<any>}\n */\n\n/* istanbul ignore next */\n\nexport const rtop = request => promise.create((resolve, reject) => {\n  /* istanbul ignore next */\n  // @ts-ignore\n  request.onerror = event => reject(new Error(event.target.error));\n  /* istanbul ignore next */\n  // @ts-ignore\n\n\n  request.onblocked = () => location.reload(); // @ts-ignore\n\n\n  request.onsuccess = event => resolve(event.target.result);\n});\n/**\n * @param {string} name\n * @param {function(IDBDatabase):any} initDB Called when the database is first created\n * @return {Promise<IDBDatabase>}\n */\n\n/* istanbul ignore next */\n\nexport const openDB = (name, initDB) => promise.create((resolve, reject) => {\n  const request = indexedDB.open(name);\n  /**\n   * @param {any} event\n   */\n\n  request.onupgradeneeded = event => initDB(event.target.result);\n  /* istanbul ignore next */\n\n  /**\n   * @param {any} event\n   */\n\n\n  request.onerror = event => reject(error.create(event.target.error));\n  /* istanbul ignore next */\n\n\n  request.onblocked = () => location.reload();\n  /**\n   * @param {any} event\n   */\n\n\n  request.onsuccess = event => {\n    /**\n     * @type {IDBDatabase}\n     */\n    const db = event.target.result;\n    /* istanbul ignore next */\n\n    db.onversionchange = () => {\n      db.close();\n    };\n    /* istanbul ignore if */\n\n\n    if (typeof addEventListener !== 'undefined') {\n      addEventListener('unload', () => db.close());\n    }\n\n    resolve(db);\n  };\n});\n/**\n * @param {string} name\n */\n\n/* istanbul ignore next */\n\nexport const deleteDB = name => rtop(indexedDB.deleteDatabase(name));\n/**\n * @param {IDBDatabase} db\n * @param {Array<Array<string>|Array<string|IDBObjectStoreParameters|undefined>>} definitions\n */\n\n/* istanbul ignore next */\n\nexport const createStores = (db, definitions) => definitions.forEach(d => // @ts-ignore\ndb.createObjectStore.apply(db, d));\n/**\n * @param {IDBDatabase} db\n * @param {Array<string>} stores\n * @param {\"readwrite\"|\"readonly\"} [access]\n * @return {Array<IDBObjectStore>}\n */\n\nexport const transact = (db, stores, access = 'readwrite') => {\n  const transaction = db.transaction(stores, access);\n  return stores.map(store => getStore(transaction, store));\n};\n/**\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange} [range]\n * @return {Promise<number>}\n */\n\n/* istanbul ignore next */\n\nexport const count = (store, range) => rtop(store.count(range));\n/**\n * @param {IDBObjectStore} store\n * @param {String | number | ArrayBuffer | Date | Array<any> } key\n * @return {Promise<String | number | ArrayBuffer | Date | Array<any>>}\n */\n\n/* istanbul ignore next */\n\nexport const get = (store, key) => rtop(store.get(key));\n/**\n * @param {IDBObjectStore} store\n * @param {String | number | ArrayBuffer | Date | IDBKeyRange | Array<any> } key\n */\n\n/* istanbul ignore next */\n\nexport const del = (store, key) => rtop(store.delete(key));\n/**\n * @param {IDBObjectStore} store\n * @param {String | number | ArrayBuffer | Date | boolean} item\n * @param {String | number | ArrayBuffer | Date | Array<any>} [key]\n */\n\n/* istanbul ignore next */\n\nexport const put = (store, item, key) => rtop(store.put(item, key));\n/**\n * @param {IDBObjectStore} store\n * @param {String | number | ArrayBuffer | Date | boolean}  item\n * @param {String | number | ArrayBuffer | Date | Array<any>}  key\n * @return {Promise<any>}\n */\n\n/* istanbul ignore next */\n\nexport const add = (store, item, key) => rtop(store.add(item, key));\n/**\n * @param {IDBObjectStore} store\n * @param {String | number | ArrayBuffer | Date}  item\n * @return {Promise<number>} Returns the generated key\n */\n\n/* istanbul ignore next */\n\nexport const addAutoKey = (store, item) => rtop(store.add(item));\n/**\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange} [range]\n * @return {Promise<Array<any>>}\n */\n\n/* istanbul ignore next */\n\nexport const getAll = (store, range) => rtop(store.getAll(range));\n/**\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange} [range]\n * @return {Promise<Array<any>>}\n */\n\n/* istanbul ignore next */\n\nexport const getAllKeys = (store, range) => rtop(store.getAllKeys(range));\n/**\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange|null} query\n * @param {'next'|'prev'|'nextunique'|'prevunique'} direction\n * @return {Promise<any>}\n */\n\nexport const queryFirst = (store, query, direction) => {\n  /**\n   * @type {any}\n   */\n  let first = null;\n  return iterateKeys(store, query, key => {\n    first = key;\n    return false;\n  }, direction).then(() => first);\n};\n/**\n * @param {IDBObjectStore} store\n * @return {Promise<any>}\n */\n\nexport const getLastKey = store => queryFirst(store, null, 'prev');\n/**\n * @param {IDBObjectStore} store\n * @return {Promise<any>}\n */\n\nexport const getFirstKey = store => queryFirst(store, null, 'prev');\n/**\n * @typedef KeyValuePair\n * @type {Object}\n * @property {any} k key\n * @property {any} v Value\n */\n\n/**\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange} [range]\n * @return {Promise<Array<KeyValuePair>>}\n */\n\n/* istanbul ignore next */\n\nexport const getAllKeysValues = (store, range) => // @ts-ignore\npromise.all([getAllKeys(store, range), getAll(store, range)]).then(([ks, vs]) => ks.map((k, i) => ({\n  k,\n  v: vs[i]\n})));\n/**\n * @param {any} request\n * @param {function(IDBCursorWithValue):void|boolean} f\n * @return {Promise<void>}\n */\n\n/* istanbul ignore next */\n\nconst iterateOnRequest = (request, f) => promise.create((resolve, reject) => {\n  /* istanbul ignore next */\n  request.onerror = reject;\n  /**\n   * @param {any} event\n   */\n\n  request.onsuccess = event => {\n    const cursor = event.target.result;\n\n    if (cursor === null || f(cursor) === false) {\n      return resolve();\n    }\n\n    cursor.continue();\n  };\n});\n/**\n * Iterate on keys and values\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange|null} keyrange\n * @param {function(any,any):void|boolean} f Callback that receives (value, key)\n * @param {'next'|'prev'|'nextunique'|'prevunique'} direction\n */\n\n/* istanbul ignore next */\n\n\nexport const iterate = (store, keyrange, f, direction = 'next') => iterateOnRequest(store.openCursor(keyrange, direction), cursor => f(cursor.value, cursor.key));\n/**\n * Iterate on the keys (no values)\n *\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange|null} keyrange\n * @param {function(any):void|boolean} f callback that receives the key\n * @param {'next'|'prev'|'nextunique'|'prevunique'} direction\n */\n\n/* istanbul ignore next */\n\nexport const iterateKeys = (store, keyrange, f, direction = 'next') => iterateOnRequest(store.openKeyCursor(keyrange, direction), cursor => f(cursor.key));\n/**\n * Open store from transaction\n * @param {IDBTransaction} t\n * @param {String} store\n * @returns {IDBObjectStore}\n */\n\n/* istanbul ignore next */\n\nexport const getStore = (t, store) => t.objectStore(store);\n/**\n * @param {any} lower\n * @param {any} upper\n * @param {boolean} lowerOpen\n * @param {boolean} upperOpen\n */\n\n/* istanbul ignore next */\n\nexport const createIDBKeyRangeBound = (lower, upper, lowerOpen, upperOpen) => IDBKeyRange.bound(lower, upper, lowerOpen, upperOpen);\n/**\n * @param {any} upper\n * @param {boolean} upperOpen\n */\n\n/* istanbul ignore next */\n\nexport const createIDBKeyRangeUpperBound = (upper, upperOpen) => IDBKeyRange.upperBound(upper, upperOpen);\n/**\n * @param {any} lower\n * @param {boolean} lowerOpen\n */\n\n/* istanbul ignore next */\n\nexport const createIDBKeyRangeLowerBound = (lower, lowerOpen) => IDBKeyRange.lowerBound(lower, lowerOpen);","map":{"version":3,"sources":["/home/aksaakov/Projects/collaborative-editor/node_modules/lib0/indexeddb.js"],"names":["promise","error","rtop","request","create","resolve","reject","onerror","event","Error","target","onblocked","location","reload","onsuccess","result","openDB","name","initDB","indexedDB","open","onupgradeneeded","db","onversionchange","close","addEventListener","deleteDB","deleteDatabase","createStores","definitions","forEach","d","createObjectStore","apply","transact","stores","access","transaction","map","store","getStore","count","range","get","key","del","delete","put","item","add","addAutoKey","getAll","getAllKeys","queryFirst","query","direction","first","iterateKeys","then","getLastKey","getFirstKey","getAllKeysValues","all","ks","vs","k","i","v","iterateOnRequest","f","cursor","continue","iterate","keyrange","openCursor","value","openKeyCursor","t","objectStore","createIDBKeyRangeBound","lower","upper","lowerOpen","upperOpen","IDBKeyRange","bound","createIDBKeyRangeUpperBound","upperBound","createIDBKeyRangeLowerBound","lowerBound"],"mappings":"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","sourcesContent":["/* eslint-env browser */\n\n/**\n * Helpers to work with IndexedDB.\n *\n * @module idb\n */\n\nimport * as promise from './promise.js'\nimport * as error from './error.js'\n\n/**\n * IDB Request to Promise transformer\n *\n * @param {IDBRequest} request\n * @return {Promise<any>}\n */\n/* istanbul ignore next */\nexport const rtop = request => promise.create((resolve, reject) => {\n  /* istanbul ignore next */\n  // @ts-ignore\n  request.onerror = event => reject(new Error(event.target.error))\n  /* istanbul ignore next */\n  // @ts-ignore\n  request.onblocked = () => location.reload()\n  // @ts-ignore\n  request.onsuccess = event => resolve(event.target.result)\n})\n\n/**\n * @param {string} name\n * @param {function(IDBDatabase):any} initDB Called when the database is first created\n * @return {Promise<IDBDatabase>}\n */\n/* istanbul ignore next */\nexport const openDB = (name, initDB) => promise.create((resolve, reject) => {\n  const request = indexedDB.open(name)\n  /**\n   * @param {any} event\n   */\n  request.onupgradeneeded = event => initDB(event.target.result)\n  /* istanbul ignore next */\n  /**\n   * @param {any} event\n   */\n  request.onerror = event => reject(error.create(event.target.error))\n  /* istanbul ignore next */\n  request.onblocked = () => location.reload()\n  /**\n   * @param {any} event\n   */\n  request.onsuccess = event => {\n    /**\n     * @type {IDBDatabase}\n     */\n    const db = event.target.result\n    /* istanbul ignore next */\n    db.onversionchange = () => { db.close() }\n    /* istanbul ignore if */\n    if (typeof addEventListener !== 'undefined') {\n      addEventListener('unload', () => db.close())\n    }\n    resolve(db)\n  }\n})\n\n/**\n * @param {string} name\n */\n/* istanbul ignore next */\nexport const deleteDB = name => rtop(indexedDB.deleteDatabase(name))\n\n/**\n * @param {IDBDatabase} db\n * @param {Array<Array<string>|Array<string|IDBObjectStoreParameters|undefined>>} definitions\n */\n/* istanbul ignore next */\nexport const createStores = (db, definitions) => definitions.forEach(d =>\n  // @ts-ignore\n  db.createObjectStore.apply(db, d)\n)\n\n/**\n * @param {IDBDatabase} db\n * @param {Array<string>} stores\n * @param {\"readwrite\"|\"readonly\"} [access]\n * @return {Array<IDBObjectStore>}\n */\nexport const transact = (db, stores, access = 'readwrite') => {\n  const transaction = db.transaction(stores, access)\n  return stores.map(store => getStore(transaction, store))\n}\n\n/**\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange} [range]\n * @return {Promise<number>}\n */\n/* istanbul ignore next */\nexport const count = (store, range) =>\n  rtop(store.count(range))\n\n/**\n * @param {IDBObjectStore} store\n * @param {String | number | ArrayBuffer | Date | Array<any> } key\n * @return {Promise<String | number | ArrayBuffer | Date | Array<any>>}\n */\n/* istanbul ignore next */\nexport const get = (store, key) =>\n  rtop(store.get(key))\n\n/**\n * @param {IDBObjectStore} store\n * @param {String | number | ArrayBuffer | Date | IDBKeyRange | Array<any> } key\n */\n/* istanbul ignore next */\nexport const del = (store, key) =>\n  rtop(store.delete(key))\n\n/**\n * @param {IDBObjectStore} store\n * @param {String | number | ArrayBuffer | Date | boolean} item\n * @param {String | number | ArrayBuffer | Date | Array<any>} [key]\n */\n/* istanbul ignore next */\nexport const put = (store, item, key) =>\n  rtop(store.put(item, key))\n\n/**\n * @param {IDBObjectStore} store\n * @param {String | number | ArrayBuffer | Date | boolean}  item\n * @param {String | number | ArrayBuffer | Date | Array<any>}  key\n * @return {Promise<any>}\n */\n/* istanbul ignore next */\nexport const add = (store, item, key) =>\n  rtop(store.add(item, key))\n\n/**\n * @param {IDBObjectStore} store\n * @param {String | number | ArrayBuffer | Date}  item\n * @return {Promise<number>} Returns the generated key\n */\n/* istanbul ignore next */\nexport const addAutoKey = (store, item) =>\n  rtop(store.add(item))\n\n/**\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange} [range]\n * @return {Promise<Array<any>>}\n */\n/* istanbul ignore next */\nexport const getAll = (store, range) =>\n  rtop(store.getAll(range))\n\n/**\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange} [range]\n * @return {Promise<Array<any>>}\n */\n/* istanbul ignore next */\nexport const getAllKeys = (store, range) =>\n  rtop(store.getAllKeys(range))\n\n/**\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange|null} query\n * @param {'next'|'prev'|'nextunique'|'prevunique'} direction\n * @return {Promise<any>}\n */\nexport const queryFirst = (store, query, direction) => {\n  /**\n   * @type {any}\n   */\n  let first = null\n  return iterateKeys(store, query, key => {\n    first = key\n    return false\n  }, direction).then(() => first)\n}\n\n/**\n * @param {IDBObjectStore} store\n * @return {Promise<any>}\n */\nexport const getLastKey = store => queryFirst(store, null, 'prev')\n\n/**\n * @param {IDBObjectStore} store\n * @return {Promise<any>}\n */\nexport const getFirstKey = store => queryFirst(store, null, 'prev')\n\n/**\n * @typedef KeyValuePair\n * @type {Object}\n * @property {any} k key\n * @property {any} v Value\n */\n\n/**\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange} [range]\n * @return {Promise<Array<KeyValuePair>>}\n */\n/* istanbul ignore next */\nexport const getAllKeysValues = (store, range) =>\n  // @ts-ignore\n  promise.all([getAllKeys(store, range), getAll(store, range)]).then(([ks, vs]) => ks.map((k, i) => ({ k, v: vs[i] })))\n\n/**\n * @param {any} request\n * @param {function(IDBCursorWithValue):void|boolean} f\n * @return {Promise<void>}\n */\n/* istanbul ignore next */\nconst iterateOnRequest = (request, f) => promise.create((resolve, reject) => {\n  /* istanbul ignore next */\n  request.onerror = reject\n  /**\n   * @param {any} event\n   */\n  request.onsuccess = event => {\n    const cursor = event.target.result\n    if (cursor === null || f(cursor) === false) {\n      return resolve()\n    }\n    cursor.continue()\n  }\n})\n\n/**\n * Iterate on keys and values\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange|null} keyrange\n * @param {function(any,any):void|boolean} f Callback that receives (value, key)\n * @param {'next'|'prev'|'nextunique'|'prevunique'} direction\n */\n/* istanbul ignore next */\nexport const iterate = (store, keyrange, f, direction = 'next') =>\n  iterateOnRequest(store.openCursor(keyrange, direction), cursor => f(cursor.value, cursor.key))\n\n/**\n * Iterate on the keys (no values)\n *\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange|null} keyrange\n * @param {function(any):void|boolean} f callback that receives the key\n * @param {'next'|'prev'|'nextunique'|'prevunique'} direction\n */\n/* istanbul ignore next */\nexport const iterateKeys = (store, keyrange, f, direction = 'next') =>\n  iterateOnRequest(store.openKeyCursor(keyrange, direction), cursor => f(cursor.key))\n\n/**\n * Open store from transaction\n * @param {IDBTransaction} t\n * @param {String} store\n * @returns {IDBObjectStore}\n */\n/* istanbul ignore next */\nexport const getStore = (t, store) => t.objectStore(store)\n\n/**\n * @param {any} lower\n * @param {any} upper\n * @param {boolean} lowerOpen\n * @param {boolean} upperOpen\n */\n/* istanbul ignore next */\nexport const createIDBKeyRangeBound = (lower, upper, lowerOpen, upperOpen) => IDBKeyRange.bound(lower, upper, lowerOpen, upperOpen)\n\n/**\n * @param {any} upper\n * @param {boolean} upperOpen\n */\n/* istanbul ignore next */\nexport const createIDBKeyRangeUpperBound = (upper, upperOpen) => IDBKeyRange.upperBound(upper, upperOpen)\n\n/**\n * @param {any} lower\n * @param {boolean} lowerOpen\n */\n/* istanbul ignore next */\nexport const createIDBKeyRangeLowerBound = (lower, lowerOpen) => IDBKeyRange.lowerBound(lower, lowerOpen)\n"]},"metadata":{},"sourceType":"module"}