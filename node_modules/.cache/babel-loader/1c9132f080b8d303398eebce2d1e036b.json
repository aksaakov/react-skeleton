{"ast":null,"code":"/* eslint-env browser */\n\n/**\n * Tiny websocket connection handler.\n *\n * Implements exponential backoff reconnects, ping/pong, and a nice event system using [lib0/observable].\n *\n * @module websocket\n */\nimport { Observable } from './observable.js';\nimport * as time from './time.js';\nimport * as math from './math.js';\nconst reconnectTimeoutBase = 1200;\nconst maxReconnectTimeout = 2500; // @todo - this should depend on awareness.outdatedTime\n\nconst messageReconnectTimeout = 30000;\n/**\n * @param {WebsocketClient} wsclient\n */\n\nconst setupWS = wsclient => {\n  if (wsclient.shouldConnect && wsclient.ws === null) {\n    const websocket = new WebSocket(wsclient.url);\n    const binaryType = wsclient.binaryType;\n    /**\n     * @type {any}\n     */\n\n    let pingTimeout = null;\n\n    if (binaryType) {\n      websocket.binaryType = binaryType;\n    }\n\n    wsclient.ws = websocket;\n    wsclient.connecting = true;\n    wsclient.connected = false;\n\n    websocket.onmessage = event => {\n      wsclient.lastMessageReceived = time.getUnixTime();\n      const data = event.data;\n      const message = typeof data === 'string' ? JSON.parse(data) : data;\n\n      if (message && message.type === 'pong') {\n        clearTimeout(pingTimeout);\n        pingTimeout = setTimeout(sendPing, messageReconnectTimeout / 2);\n      }\n\n      wsclient.emit('message', [message, wsclient]);\n    };\n    /**\n     * @param {any} error\n     */\n\n\n    const onclose = error => {\n      if (wsclient.ws !== null) {\n        wsclient.ws = null;\n        wsclient.connecting = false;\n\n        if (wsclient.connected) {\n          wsclient.connected = false;\n          wsclient.emit('disconnect', [{\n            type: 'disconnect',\n            error\n          }, wsclient]);\n        } else {\n          wsclient.unsuccessfulReconnects++;\n        } // Start with no reconnect timeout and increase timeout by\n        // log10(wsUnsuccessfulReconnects).\n        // The idea is to increase reconnect timeout slowly and have no reconnect\n        // timeout at the beginning (log(1) = 0)\n\n\n        setTimeout(setupWS, math.min(math.log10(wsclient.unsuccessfulReconnects + 1) * reconnectTimeoutBase, maxReconnectTimeout), wsclient);\n      }\n\n      clearTimeout(pingTimeout);\n    };\n\n    const sendPing = () => {\n      if (wsclient.ws === websocket) {\n        wsclient.send({\n          type: 'ping'\n        });\n      }\n    };\n\n    websocket.onclose = () => onclose(null);\n\n    websocket.onerror = error => onclose(error);\n\n    websocket.onopen = () => {\n      wsclient.lastMessageReceived = time.getUnixTime();\n      wsclient.connecting = false;\n      wsclient.connected = true;\n      wsclient.unsuccessfulReconnects = 0;\n      wsclient.emit('connect', [{\n        type: 'connect'\n      }, wsclient]); // set ping\n\n      pingTimeout = setTimeout(sendPing, messageReconnectTimeout / 2);\n    };\n  }\n};\n/**\n * @extends Observable<string>\n */\n\n\nexport class WebsocketClient extends Observable {\n  /**\n   * @param {string} url\n   * @param {object} [opts]\n   * @param {'arraybuffer' | 'blob' | null} [opts.binaryType] Set `ws.binaryType`\n   */\n  constructor(url, {\n    binaryType\n  } = {}) {\n    super();\n    this.url = url;\n    /**\n     * @type {WebSocket?}\n     */\n\n    this.ws = null;\n    this.binaryType = binaryType || null;\n    this.connected = false;\n    this.connecting = false;\n    this.unsuccessfulReconnects = 0;\n    this.lastMessageReceived = 0;\n    /**\n     * Whether to connect to other peers or not\n     * @type {boolean}\n     */\n\n    this.shouldConnect = true;\n    this._checkInterval = setInterval(() => {\n      if (this.connected && messageReconnectTimeout < time.getUnixTime() - this.lastMessageReceived) {\n        // no message received in a long time - not even your own awareness\n        // updates (which are updated every 15 seconds)\n\n        /** @type {WebSocket} */\n        this.ws.close();\n      }\n    }, messageReconnectTimeout / 2);\n    setupWS(this);\n  }\n  /**\n   * @param {any} message\n   */\n\n\n  send(message) {\n    if (this.ws) {\n      this.ws.send(JSON.stringify(message));\n    }\n  }\n\n  destroy() {\n    clearInterval(this._checkInterval);\n    this.disconnect();\n    super.destroy();\n  }\n\n  disconnect() {\n    this.shouldConnect = false;\n\n    if (this.ws !== null) {\n      this.ws.close();\n    }\n  }\n\n  connect() {\n    this.shouldConnect = true;\n\n    if (!this.connected && this.ws === null) {\n      setupWS(this);\n    }\n  }\n\n}","map":{"version":3,"sources":["/home/aksaakov/Projects/collaborative-editor/node_modules/lib0/websocket.js"],"names":["Observable","time","math","reconnectTimeoutBase","maxReconnectTimeout","messageReconnectTimeout","setupWS","wsclient","shouldConnect","ws","websocket","WebSocket","url","binaryType","pingTimeout","connecting","connected","onmessage","event","lastMessageReceived","getUnixTime","data","message","JSON","parse","type","clearTimeout","setTimeout","sendPing","emit","onclose","error","unsuccessfulReconnects","min","log10","send","onerror","onopen","WebsocketClient","constructor","_checkInterval","setInterval","close","stringify","destroy","clearInterval","disconnect","connect"],"mappings":"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","sourcesContent":["/* eslint-env browser */\n\n/**\n * Tiny websocket connection handler.\n *\n * Implements exponential backoff reconnects, ping/pong, and a nice event system using [lib0/observable].\n *\n * @module websocket\n */\n\nimport { Observable } from './observable.js'\nimport * as time from './time.js'\nimport * as math from './math.js'\n\nconst reconnectTimeoutBase = 1200\nconst maxReconnectTimeout = 2500\n// @todo - this should depend on awareness.outdatedTime\nconst messageReconnectTimeout = 30000\n\n/**\n * @param {WebsocketClient} wsclient\n */\nconst setupWS = (wsclient) => {\n  if (wsclient.shouldConnect && wsclient.ws === null) {\n    const websocket = new WebSocket(wsclient.url)\n    const binaryType = wsclient.binaryType\n    /**\n     * @type {any}\n     */\n    let pingTimeout = null\n    if (binaryType) {\n      websocket.binaryType = binaryType\n    }\n    wsclient.ws = websocket\n    wsclient.connecting = true\n    wsclient.connected = false\n    websocket.onmessage = event => {\n      wsclient.lastMessageReceived = time.getUnixTime()\n      const data = event.data\n      const message = typeof data === 'string' ? JSON.parse(data) : data\n      if (message && message.type === 'pong') {\n        clearTimeout(pingTimeout)\n        pingTimeout = setTimeout(sendPing, messageReconnectTimeout / 2)\n      }\n      wsclient.emit('message', [message, wsclient])\n    }\n    /**\n     * @param {any} error\n     */\n    const onclose = error => {\n      if (wsclient.ws !== null) {\n        wsclient.ws = null\n        wsclient.connecting = false\n        if (wsclient.connected) {\n          wsclient.connected = false\n          wsclient.emit('disconnect', [{ type: 'disconnect', error }, wsclient])\n        } else {\n          wsclient.unsuccessfulReconnects++\n        }\n        // Start with no reconnect timeout and increase timeout by\n        // log10(wsUnsuccessfulReconnects).\n        // The idea is to increase reconnect timeout slowly and have no reconnect\n        // timeout at the beginning (log(1) = 0)\n        setTimeout(setupWS, math.min(math.log10(wsclient.unsuccessfulReconnects + 1) * reconnectTimeoutBase, maxReconnectTimeout), wsclient)\n      }\n      clearTimeout(pingTimeout)\n    }\n    const sendPing = () => {\n      if (wsclient.ws === websocket) {\n        wsclient.send({\n          type: 'ping'\n        })\n      }\n    }\n    websocket.onclose = () => onclose(null)\n    websocket.onerror = error => onclose(error)\n    websocket.onopen = () => {\n      wsclient.lastMessageReceived = time.getUnixTime()\n      wsclient.connecting = false\n      wsclient.connected = true\n      wsclient.unsuccessfulReconnects = 0\n      wsclient.emit('connect', [{ type: 'connect' }, wsclient])\n      // set ping\n      pingTimeout = setTimeout(sendPing, messageReconnectTimeout / 2)\n    }\n  }\n}\n\n/**\n * @extends Observable<string>\n */\nexport class WebsocketClient extends Observable {\n  /**\n   * @param {string} url\n   * @param {object} [opts]\n   * @param {'arraybuffer' | 'blob' | null} [opts.binaryType] Set `ws.binaryType`\n   */\n  constructor (url, { binaryType } = {}) {\n    super()\n    this.url = url\n    /**\n     * @type {WebSocket?}\n     */\n    this.ws = null\n    this.binaryType = binaryType || null\n    this.connected = false\n    this.connecting = false\n    this.unsuccessfulReconnects = 0\n    this.lastMessageReceived = 0\n    /**\n     * Whether to connect to other peers or not\n     * @type {boolean}\n     */\n    this.shouldConnect = true\n    this._checkInterval = setInterval(() => {\n      if (this.connected && messageReconnectTimeout < time.getUnixTime() - this.lastMessageReceived) {\n        // no message received in a long time - not even your own awareness\n        // updates (which are updated every 15 seconds)\n        /** @type {WebSocket} */ (this.ws).close()\n      }\n    }, messageReconnectTimeout / 2)\n    setupWS(this)\n  }\n\n  /**\n   * @param {any} message\n   */\n  send (message) {\n    if (this.ws) {\n      this.ws.send(JSON.stringify(message))\n    }\n  }\n\n  destroy () {\n    clearInterval(this._checkInterval)\n    this.disconnect()\n    super.destroy()\n  }\n\n  disconnect () {\n    this.shouldConnect = false\n    if (this.ws !== null) {\n      this.ws.close()\n    }\n  }\n\n  connect () {\n    this.shouldConnect = true\n    if (!this.connected && this.ws === null) {\n      setupWS(this)\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}